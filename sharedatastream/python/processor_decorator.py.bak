import shared_ring_queue
import threading
import time
import inspect
from typing import Optional, Dict, Any

class SharedMemConsumerWrapper:
    def __init__(self, in_shm, in_queue_len, in_block_size, batch_size=1, timeout_ms=10):
        self.proc = shared_ring_queue.SharedMemProcessor(
            in_shm, in_queue_len, in_block_size,
            out_shm="", out_queue_len=0, out_block_size=0,
            total_refs=1, metadata="", batch_size=batch_size, timeout_ms=timeout_ms
        )
        self._thread = None
        self._callback = None
        self._original_pyfunc = None
    def register(self, pyfunc):
        def callback(batch):
            py_batch = [bytes(x) for x in batch]
            return pyfunc(py_batch)
        self._callback = pyfunc
        self._original_pyfunc = pyfunc
        self.proc.register_callback(callback)
    def start(self):
        self.proc.start()
    def stop(self):
        self.proc.stop()

class SharedMemProducerWrapper:
    def __init__(self, out_shm, out_queue_len, out_block_size, interval=0.01):
        self.proc = shared_ring_queue.SharedMemProcessor(
            in_shm="", in_queue_len=0, in_block_size=0,
            out_shm=out_shm, out_queue_len=out_queue_len, out_block_size=out_block_size,
            total_refs=1, metadata=""
        )
        self._thread = None
        self._callback = None
        self.interval = interval
        self._consumer_wrapper = None
    def set_consumer(self, consumer_wrapper):
        self._consumer_wrapper = consumer_wrapper
    def register(self, pyfunc):
        self._callback = pyfunc
        if self._consumer_wrapper:
            original_pyfunc = find_original_pyfunc(pyfunc)
            def prod_callback(batch):
                result = original_pyfunc(batch)
                if inspect.isgenerator(result):
                    for item in result:
                        self.proc.push_to_output(item)
                elif result is not None:
                    self.proc.push_to_output(result)
                return []
            self._consumer_wrapper.proc.register_callback(prod_callback)
        else:
            def loop():
                while True:
                    result = pyfunc()
                    if inspect.isgenerator(result):
                        for item in result:
                            self.proc.push_to_output(item)
                    elif result is not None:
                        self.proc.push_to_output(result)
                    time.sleep(self.interval)
            self._thread = threading.Thread(target=loop, daemon=True)
            self._thread.start()
    def push_to_output(self, data: bytes):
        return self.proc.push_to_output(data)
    def stop(self):
        self.proc.stop()

# 用法：
# @sharedmem_producer(...)
# @sharedmem_consumer(...)
# def func(batch):
#     for x in batch:
#         yield ...
# 或 return ...

def sharedmem_consumer(*args, **kwargs):
    """
    支持参数对象(dict)或命名参数，便于main函数动态传参。
    """
    def decorator(pyfunc):
        if args and isinstance(args[0], dict):
            params = args[0]
        else:
            params = kwargs
        wrapper = SharedMemConsumerWrapper(
            params.get('in_shm', ''),
            params.get('in_queue_len', 0),
            params.get('in_block_size', 0),
            params.get('batch_size', 1),
            params.get('timeout_ms', 10)
        )
        wrapper.register(pyfunc)
        t = threading.Thread(target=wrapper.start, daemon=True)
        t.start()
        wrapper._consumer_wrapper = wrapper
        return wrapper
    return decorator

def find_consumer_wrapper(obj):
    checked = set()
    while obj is not None and id(obj) not in checked:
        checked.add(id(obj))
        if hasattr(obj, '_consumer_wrapper'):
            next_obj = getattr(obj, '_consumer_wrapper')
            if next_obj is obj:
                return obj
            obj = next_obj
        else:
            return None
    return None

def find_original_pyfunc(obj):
    checked = set()
    while obj is not None and id(obj) not in checked:
        checked.add(id(obj))
        if hasattr(obj, '_original_pyfunc'):
            obj = getattr(obj, '_original_pyfunc')
        else:
            return obj
    return obj

def sharedmem_producer(*args, **kwargs):
    """
    支持参数对象(dict)或命名参数，便于main函数动态传参。
    """
    def decorator(pyfunc):
        if args and isinstance(args[0], dict):
            params = args[0]
        else:
            params = kwargs
        wrapper = SharedMemProducerWrapper(
            params.get('out_shm', ''),
            params.get('out_queue_len', 0),
            params.get('out_block_size', 0),
            params.get('interval', 0.01)
        )
        consumer_wrapper = find_consumer_wrapper(pyfunc)
        if consumer_wrapper:
            wrapper.set_consumer(consumer_wrapper)
        wrapper.register(pyfunc)
        wrapper._producer_wrapper = wrapper
        return wrapper
    return decorator 